Классы проектирования.
1. GameManager - класс, контролирующий игру - состояния, конфигурацию и т.д. 
Реализовать с помощью Singleton - единственный экземпляр объекта и единая точка доступа.

2. TurnManager - предполагается использовать паттерн Observer, который будет предоставлять
интерфейс для уведомления других классов (объектов) об изменении состояния - игрок сделал
ход и необходимости предпринять при этом нужные действия - перерисовать сетку, посчитать очки
 и т.д.

3. IBonusStrategy - поскольку в игре предполагается явное использование разных алгоритмов
активации бонусов то полезно будет сразу выделить это поведение в интерфейс, отвязав
клиентов от реализации конкретного поведения. 

4. ElementFactory - поскольку в игре будет использован фиксированный набор элементов, при этом они 
будут переиспользоваться множество раз, чтобы не выделять память постоянно, можно использовать
паттерн Flyweight - получать объект если он уже был создан из словаря объектов, а не создавать 
каждый раз новый

5. GameStateManager - название пока ориентировочное, и вероятно паттерн будет использован в другом 
классе. В зависимости от различного состояния игры (ожидается ход игрока, game over, пересчет поля...)
игрок может выполнять разные наборы операций, и предполагается их контролировать с использованием
паттерна State.

***
Другие возможные для применения паттерны, которые потенциально могут быть полезными
и в итоге окажутся внедрены в проект, но на данном этапе пока не кажутся столь необходимыми:
-- Посредник (Mediator) - возможно будет использован для взаимодействия между классами.
-- TemplateMethod - если стратегия окажется избыточной, или бонусы должны будут иметь базовый алгоритмов
с незначительными изменениями лишь его части, стоит использовать данный шаблон вместо стратегии