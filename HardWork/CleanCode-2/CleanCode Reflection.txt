Задание выполнил в текстовом формате, порефлексировал по памяти и по текущим проектам.

2. Уровень классов.
1) Слишком большой класс
В моём опыте так получалось, когда например в доменную модель приходилось для удобства добавить все необходимые поля
При этом зачастую поля наполнялись из разных источников (БД, вызов внешнего сервиса ...)
На мой взгляд это плохо потому, что этот класс связывает разные места (или даже слои) в программе
Плюс такие большие классы тяжелее тестировать

2) Слишком маленький класс
Обратная сторона, когда класс слишком маленький, может случится так, что поля, 
которые объединены одним контекстом оказываются в разных классах, что осложняет сопровождение. 

3) В классе есть метод, который выглядит более подходящим для другого класса.
Такое случается кажется довольно часто, поскольку разработчики, слабо знакомые с приложением могут просто 
не найти более подходящий (и правильный) класс

4) Класс хранит данные, которые загоняются в него во множетсве мест в программе.
В своей практике сталкивался с этим, когда появляется доменная модель, при этом часть полей необходимо 
каким-то образом обогатить (например запросами
из внешних сервисов)
Кажется если это происходит разово (для 1 поля) - это приемлимо, но для нескольких таких "обогащений" стоит 
пересмотреть архитектуру

5) Класс зависит от деталей реализации других классов.
Не смог придумать пример из практики. Но кажется здесь речь про нарушение DIP -- и случаться такое может при 
спонтанном добавлении функционала
без его обдумывания. Что к сожалению происходит довольно часто на моей практике

6) Приведение типов вниз по иерархии.
Мне приходилось использовать data.OfType<T> (где T - базовый родительскуий класс в иерархии) в generic реализации 
-- т.е. приводить коллекцию базового класса к конкретной коллекции. На тот момент это казалось удовлетворительным 
решением, тем более реализовывал MVP проекта.
Плохо во первых потому, что явное приведение само по себе плохо, во вторых - возможно это является следствием 
нарушения LSP - что я не могу использовать
полиморфизм, а явно приходится "вытаскивать" нужный класс.

7) Когда создаётся класс-наследник для какого-то класса, приходится создавать классы-наследники и для некоторых 
других классов.
C этим мы постоянно сталкивались в одном из центральных сервисов нашей группы
В иерархии движения был базовый класс, в котором была коллекция базовых типов, примерно вот так:
abstract class BaseMovement
{
	...
	List<BaseExemplar> exemplars
}

что приводило к тому, что при добавлении наследника от BaseMovement приходилось явно создавать наследника и BaseExemplar
Такая связанность приводила скорее к усложнению чтения и понимания иерархии.

8) Дочерние классы не используют методы и атрибуты родительских классов, или переопределяют родительские методы
С таким сталкивался, когда под общий интерфейс базового класса пытался загнать все подходящие потомки.
Однако, поскольку это происходило на раннем этапе проектированиЯ, позже выяснилось, что структура несколько отличалась 
от моих предположений,
В целом это сподвигло меня к повторению курсов по ООАП проектированию =) (пока в процессе)ч

3. Уровень приложения.

1) Одна модификация требует изменения в нескольких классах 
Если например у меня есть какая-то доменная модель,
и валидаторы, sender'ы, (и другой схожий функционал) то при добавлении например одного поля 
придётся вносить изменения как в валидаторы, так и в sender'ы, и т.д.

2) Избыточное Использование сложных паттернов проектирования.
Зачастую в проекте, когда ещё только разрабатывается MVP, сразу реализую паттерн стратегия 
(например когда логика должна зависеть от какого-то типа enum)
Если планируется расширение проекта - то это оправдано, но бывает что этот тип остаётся 1 и достаточно было 
использовать if - else или switch-case
И на старом проекте вспоминаю, что стратегии реализовывали буквально 1-2 строчки внутри себя, для чего кажется 
можно было обходиться простыми методами
в вызывающем коде
При этом сами паттерны порой усложняют "чтение" кода, особенно новыми людьми в команде.