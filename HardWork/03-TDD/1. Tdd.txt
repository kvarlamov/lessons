1. Рабочие тесты по TDD:
В рамках рабочих проектов за неделю удалось написать некоторый функционал с использованием TDD
Несколько примеров:
1.1 Реализовывал класс, выполняющий вызов внешнего grpc клиента для получения данных
Я начал с создания теста, где определил интерфейс класса
```C#
interface IExternalClient
{
    Task<ExternalResult> GetExternalAttributes(IList<long> ids, CancellationToken ct);
}
```
а также создание экземпляра - конструктор с одним аргументом -- grpc клиентом.
Поскольку класс ещё не был реализован тест логично не комплилировался - реализовал соответствующий класс
с нужным конструктором.
Далее - для каждого id из аргументов внешняя ручка возвращала историю изменений этого id
При этом должна была вернуться информация о последнем
Написал на это тест (упрощённо)
```
public void Test
{
    // Ararange
    ...
    var response = {...} // ответ grpc сервера для мока -- Dto {id:long, []Attributes(Date, ...)}
    var expected = ... // здесь определялось "последнее" dto 
    
    // Act
    var result = _client.Call() // _client - тестируемый класс, а внутри уже вызов grpc,который вернёт response
    
    // Assert
    result.Should().Be(expected) // определяю что вернулось именно последнее
}
```
Поскольку логики не было -- реализовал, далее тест "позеленел"

Благодаря этому удалось определить необходимые интерфейсы до написания первых строчек кода.
И дополнительный плюс от теста: поскольку логика наших сервисов в основном представляем собой ETL процессы (без сложной логики), 
то чаще всего пишем мы интеграционные тесты, которые кажется хорошо подходят под этот flow,
а вызовы внешних интерфейсов просто замокиваются.

1.2
Частая типовая задача добавления нового типа.
У нас есть топик, в котором в общий контракт (proto) во внутренний контракт добавляются новые типы операций.
```
message Public {
    oneof operation_type 
    {
        typedOperation.First = 1;
        typedOperation.Second = 2;
        ...
    }
}
```
Далее эти типы сериализуются и сохраняются в хранилище postgres.
При этом необходимость consume определяется через метод ShouldHandle() -- чистую ф-ию, которая на основании
hashset'а возвращает булево значение, нужно ли обрабатывать соответствующий тип.
Так вот как раз на неделе видел баг, что разработчик забыл добавить в hashset новый тип при реализации задачи
и добавлял уже после выкатки на stg (поскольку тип просто не сохранялся).
Перед добавлением нового типа я сразу написал тест, который получает все возможные значения enum из Dto контракта
и проверяет, что тип не фильтруется. Тест конечно упал
```c#
public void NotMissedAnyTypes()
{
  foreach (var type in Enum.GetValues<OneOfTypesInEnumCase>){
      AllowedConsumingTypes.Should().Contain(type);
  }
}
```
где
AllowedConsumingTypes - хэшсэт, определяющий необходимость consume конкретного типа
После добавления нужного мне типа я получил зелёный тест и защиту от ошибок коллег в будущем.


2) С акцентом на соответствие дизайну
Вначале достаточно тяжело было понять данный концепт.
Также, поскольку приступил к реализации данного пункта к концу недели, притворить его в жизнь в рабочем коде не удалось.
Поэтому реализовал в личном проекте.
Накануне НГ для личного пользования решил реализовать в телеграме бота "Тайный Санта".
И вот тут начал не с кода или тестов, а с обдумывания дизайна.
Вспомнив что еще не стёрлось из памяти по курсу проектирования ООАП (обязательно нужно повторить -- много забыто), 
описал тех задание и выделил несколько базовых классов 
(по факту обошёлся лишь классом расчёта, репозиторием и хэндлерами команд медиатора).
Логика проста: люди добавляют себя в качестве желающих, потом выполняется расчёт. И каждый может запросить
для кого является тайным Сантой и получить ответ в ЛС.

Дальше приступил к TDD.
В качестве ЯП выбрал малознакомый Goland и в итоге мне это даже помогло =)
Поскольку с синтаксисом ЯП был знаком лишь поверхностно, 
мозг не старался сразу воплотить тз в код (поскольку синтаксис наизусть почти не знаю), поэтому держал в голове то,
что должны делать сущности на уровне дизайна(логики).
Например, выделив "Репозиторий пользователей", определил минимальный набор полей
```go
type User struct {
	ID       int    `json:"id"`
	UserName string `json:"user_name"`
	Name     string `json:"name"`
	TargetID int    `json:"target_id"`
}
```
и сразу спроектировал интерфейс репозитория:
 
```go
type UserRepositoryInterface interface {
	GetSecretSanta(username string) (*contracts.User, error)
	AddUser(newUser contracts.User) (*contracts.User, error)
	GetAllUsers() ([]contracts.User, error)
	UpdateAll(usersToUpdate []contracts.User) error
}
```
После этого выделил чистый метод для расчёта (получает пользователей выполняет расчёт тайных сант)

Функционал ещё в процессе реализации, но такой подход к TDD определённо помогает добиваться выполнения целей проекта,
а с тестами и реализацией пока помогает LLM.

Финал:

К сожалению задание выполнено лишь частично ввиду отсутствия практики разработки т.о.
Несколько раз перечитывал материалы из Сильных идей, но даже с учётом практики
такой разработки думать оказалось весьма сложно.
При этом неожиданно оказалось, что плохое знание синтаксиса даже полезно --
не зная как это написать, думаешь больше то, что нужно "писать".
Но даже несмотря на это -- удалось оценить пользу данного подхода.
Без размышлений на уровне дизайна код часто пишется автоматически, например, по аналогии с соседними реализациями
(в худшем варианте копипастой).
Написание же тестов позволяет чаще(постоянно) обдумывать идеи того, что делает наша программа, а не код.

Финальный вывод:
не могу сказать, что я полностью разобрался в этом, всё ещё предстоит написать ещё сотни строк кода,
но заданик показало очевидную пользу этого -- буду стараться применять.
