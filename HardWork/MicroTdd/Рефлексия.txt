1 Задача - простой сервис кэширования.
код:
https://github.com/kvarlamov/lessons/tree/main/HardWork/MicroTdd/CacheService
тесты:
https://github.com/kvarlamov/lessons/tree/main/HardWork/MicroTdd/CacheService.Tests

Первая задача с реализацией указанного подхода далась весьма сложно.
Например, начал писать тест на метод кэширования, но потом понадобилась модель User.
Реализовал её -> понадобились тесты на User. При этом уже была часть кода на CacheService.
Начинаешь писать тест на один класс, понимаешь, что чего-то не хватает в дто, пишешь другой тест.
По итогу сделал вывод, что нужно было лучше продумать ТЗ и стараться покрывать тестами каждую новую
"обязанность" добавляемого функционала.

2 задача - CircuitBreaker (упрощенный, без полуоткрытого состояния).
код:
https://github.com/kvarlamov/lessons/blob/main/HardWork/MicroTdd/CircuitBreaker/CircuitBreaker.cs
тесты:
https://github.com/kvarlamov/lessons/blob/main/HardWork/MicroTdd/CircuitBreaker.Tests/UnitTest1.cs

С учётом прошлого постарался сначала подробно расписал необходимые сущности и составил ТЗ.
Приступил к пошаговой реализации.
При этом, хотя в этот раз шаги были явно меньше и удалось частично следовать данной методике,
я забывал коммитить, поэтому по факту получился один. Тем не менее по сравнению с первым решением был явный прогресс:
изменения стали достаточно маленькими, а в тестах класса стало как бы видны шаги добавляемых изменений. 


Третья задача - Saga паттерн для микросервисов.
код:
https://github.com/kvarlamov/lessons/blob/main/HardWork/MicroTdd/SagaPattern/Saga.cs
тесты:
https://github.com/kvarlamov/lessons/blob/main/HardWork/MicroTdd/SagaPattern.Tests/SagaTests.cs

Тут постарался двигаться минимально возможными шагами с учётом прошлых пунктов.
Начал с проверки конструктора и далее при добавлении минимального шага сразу добавлялись тесты.
Т.о. удалось последовательно добавлять и тестировать основную логику по обработке и компенсации шагов,
компенсации и обработке иключений. 
И теперь можно заметить, что тесты стали явно последовательными и следуют от "начала" к "концу" функционала.
Также заметил, что при таком подходе тестов появляется гораздо больше, 
и при этом есть уверенность в предыдущих шагах, что ничего лишнего не добавил.

Финальный вывод:
Готов ли я применять данный подход в своей работе -- наверное с покрытием каждой добавляемой строчки пока вряд ли.
Часто бывают задачи, где нужно что-то быстро изменить и то, что уже покрывают интеграционные тесты.
И если цена ошибки в проекте не очень высокая то скорее всего выберу путь с проверкой интеграционными тестами
полного флоу.

Однако мне понравилось, что с данным подходом (особенно в 3-й задаче) почти исчезает необходимость
"оборачиваться" -- когда тесты падают и приходится выяснять, что же пошло не так, прибегая к отладке (порой длительной).
К минимизации и стуктурированию коммитов я уже стараюсь прибегать в своей работе.
