Мною был изучен доработанный материал "15. Снижение цикломатической сложности (ЦС) кода как метод проектирования"
По результатам изучения составлен краткий конспект.
Основные приёмы я уже применяю в работе, однако из интересного узнал для себя паттерн "табличной логики" и 
динамическое добавление функциональности (этот приём применил в примере 3)

В примерах код разбит на регионы #region, где 
Before - исходный код
After - код после рефакторинга

Дублирую текстовое описание результатов из примеров:
В большинстве примеров удалось добиться многократного снижения ЦС (на порядки)
Пример 1: "2. First example.cx" (в примере на строке 108):
Исходная ЦС метода ProcessOrder составляла 23
 * Благодаря рефакторингу её удалось снизить до 6
 * Использованные приёмы:
 * 1) выделение вложенной в if логики в отдельные методы
 * -- выделил логикуметоды обработки заказа -- несмотря на то, что это самый простой приём и в реальном
 * продакшн коде применять не очень эффективно, даже это привело к снижению сложности и улучшению читаемости
 *
 * 2) полиморфизм
 * -- строковые поля CustomerType и PaymentMethod были переделаны в типы и добавлены через композицию
 * в тип Order, что позволило определять логику обработки конкретного типа полиморфно - через общий метод
 *
 * Вывод: для этого примера я решил ограничиться этим манипуляциями и даже их хватило, чтобы снизить ЦС почти в 4 раза
 
 Пример 2: "3. UserValidator.cs": (в примере на строке 122)
  * Исходная ЦС метода ValidateUser = 20
  * Финальная ЦС метода ValudateUser = 1
  * Приёмы:
  * 1) Использован паттерн спецификация (+ полиморфизм) -- создан базовый класс ValidationRule,
  * от которого наследуются все правила проверки
  * Также сделан класс UserValidationHandler, агрегирующий в себе правила валидации и при вызове метода Validate выполняющий
  * валидацию всех необходимых полей
  * 2) в методе AddRule используется Ad-hoc полиморфизм -- принимается базовый класс ValidationRule, по факту являющийся
  * любым из правил валидации
  *
  * 3) Убраны все else (в одном месте сохранен switch для удобства)
  * 4) Замена примитивных значений структурами -- данный приём лишь шаг на пути к финальному рефакторингу
  * -- можно было бы правила валидации вынести в сами структуры валидировать их при создании,
  * а в каждом ValidationRule лишь вызывать метод проверки внутренних правил класса (или получать статус)
  *
  * Open-Closed принцип -- код может расширяться новыми правилами валидации без изменения текущих правил
 
 Пример 3: "4. SalaryCalculator.cs": (в примере на строке 123)
  * Исходная цикломатическая сложность метода CalculateSalary = 27
  * Измененная ЦС указанного метода = 1
  * Приёмы:
  * 1) динамическое добавление чистой функциональности
  * Создан словарь, в котором по ключу (имя поля Employee) хранятся функции, отвечающие за расчёт данного поля
  * Имеется функция добавления функций для расчёта
  * 
  * 2) Выполнен рефакторинг Employee - Position из строкового поля заменено на свойство Position,
  *  которое с помощью полиморфизма определяет модификаторы для расчёта для каждого отдельного класса - позиции
  *
  * Данный приём можно было бы масштабировать и на другие поля, однако для упрощения примера не стал этого делать.

 